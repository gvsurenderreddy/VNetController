// Generated by CoffeeScript 1.9.0
(function() {
  var IPManager, StormData, StormRegistry, Topology, TopologyData, TopologyMaster, TopologyRegistry, async, authenticatorurl, extend, ip, node, request, switches, util, vnetbuilderurl, vnetprovisionerurl,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __hasProp = {}.hasOwnProperty;

  StormRegistry = require('stormregistry');

  StormData = require('stormdata');

  util = require('util');

  request = require('request-json');

  extend = require('util')._extend;

  ip = require('ip');

  async = require('async');

  vnetbuilderurl = 'http://localhost:5680/';

  vnetprovisionerurl = 'http://localhost:5681/';

  IPManager = require('./IPManager');

  node = require('./Node');

  switches = require('./Switches');

  util = require('util');

  authenticatorurl = "127.0.0.1:2222";

  TopologyRegistry = (function(_super) {
    __extends(TopologyRegistry, _super);

    function TopologyRegistry(filename) {
      this.on('load', function(key, val) {
        var entry;
        util.log("restoring " + key + " with:", val);
        entry = new TopologyData(key, val);
        if (entry != null) {
          entry.saved = true;
          return this.add(entry);
        }
      });
      this.on('removed', function(entry) {
        if (entry.destructor != null) {
          return entry.destructor();
        }
      });
      TopologyRegistry.__super__.constructor.call(this, filename);
    }

    TopologyRegistry.prototype.add = function(data) {
      var entry;
      if (!(data instanceof TopologyData)) {
        return;
      }
      return entry = TopologyRegistry.__super__.add.call(this, data.id, data);
    };

    TopologyRegistry.prototype.update = function(data) {
      return TopologyRegistry.__super__.update.call(this, data.id, data);
    };

    TopologyRegistry.prototype.get = function(key) {
      var entry;
      entry = TopologyRegistry.__super__.get.call(this, key);
      if (entry == null) {
        return;
      }
      if ((entry.data != null) && entry.data instanceof TopologyData) {
        entry.data.id = entry.id;
        return entry.data;
      } else {
        return entry;
      }
    };

    return TopologyRegistry;

  })(StormRegistry);

  TopologyData = (function(_super) {
    var TopologySchema;

    __extends(TopologyData, _super);

    TopologySchema = {
      name: "Topology",
      type: "object",
      properties: {
        name: {
          type: "string",
          required: true
        },
        projectid: {
          type: "string",
          required: true
        },
        passcode: {
          type: "string",
          required: true
        },
        switches: {
          type: "array",
          items: {
            name: "switch",
            type: "object",
            required: false,
            properties: {
              name: {
                type: "string",
                required: false
              },
              type: {
                type: "string",
                required: false
              },
              ports: {
                type: "integer",
                required: false
              },
              make: {
                type: "string",
                required: true
              }
            }
          }
        },
        nodes: {
          type: "array",
          items: {
            name: "node",
            type: "object",
            required: true,
            properties: {
              name: {
                type: "string",
                required: true
              },
              type: {
                type: "string",
                required: false
              },
              Services: {
                type: "array",
                required: true,
                items: {
                  type: "object",
                  required: true,
                  properties: {
                    name: {
                      "type": "string",
                      "required": false
                    },
                    config: {
                      type: "object",
                      required: false
                    }
                  }
                }
              }
            }
          }
        },
        links: {
          type: "array",
          items: {
            name: "node",
            type: "object",
            required: true,
            properties: {
              type: {
                type: "string",
                required: true
              },
              "switch": {
                type: "string",
                required: false
              },
              make: {
                type: "string",
                required: false
              },
              config: {
                type: "object",
                required: false
              },
              connected_nodes: {
                type: "array",
                required: true,
                items: {
                  type: "object",
                  required: true,
                  properties: {
                    name: {
                      "type": "string",
                      "required": true
                    }
                  }
                }
              }
            }
          }
        }
      }
    };

    function TopologyData(id, data) {
      TopologyData.__super__.constructor.call(this, id, data, TopologySchema);
    }

    return TopologyData;

  })(StormData);

  Topology = (function() {
    function Topology() {
      this.config = {};
      this.status = {};
      this.statistics = {};
      this.switchobj = [];
      this.nodeobj = [];
      this.linksobj = [];
    }

    Topology.prototype.getNodeObjbyName = function(name) {
      var obj, _i, _len, _ref;
      _ref = this.nodeobj;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        util.log("getNodeObjbyName" + obj.config.name);
        if (obj.config.name === name) {
          util.log("getNodeObjbyName found " + obj.config.name);
          return obj;
        }
      }
      return null;
    };

    Topology.prototype.getSwitchObjbyName = function(name) {
      var obj, _i, _len, _ref;
      util.log("inpjut for check " + name);
      _ref = this.switchobj;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        util.log("getSwitchObjbyName iteratkon " + obj.config.name);
        if (obj.config.name === name) {
          util.log("getSwitchObjbyName found " + obj.config.name);
          return obj;
        }
      }
      return null;
    };

    Topology.prototype.getSwitchObjbyUUID = function(uuid) {
      var obj, _i, _len, _ref;
      _ref = this.switchobj;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        util.log("getSwitchObjbyUUID " + obj.uuid);
        if (obj.uuid === uuid) {
          util.log("getSwitchObjbyUUID found " + obj.uuid);
          return obj;
        }
      }
      return null;
    };

    Topology.prototype.getNodeObjbyUUID = function(uuid) {
      var obj, _i, _len, _ref;
      _ref = this.nodeobj;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        util.log("getNodeObjbyUUID" + obj.uuid);
        if (obj.uuid === uuid) {
          util.log("getNodeObjbyUUID found " + obj.config.uuid);
          return obj;
        }
      }
      return null;
    };

    Topology.prototype.createSwitches = function(cb) {
      return async.each(this.switchobj, (function(_this) {
        return function(sw, callback) {
          util.log("create switch ");
          return sw.create(function(result) {
            util.log("create switch result " + JSON.stringify(result));
            return callback();
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            util.log("Error occured on createswitches function " + err);
            return cb(false);
          } else {
            util.log("createswitches completed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.startSwitches = function(cb) {
      return async.each(this.switchobj, (function(_this) {
        return function(sw, callback) {
          util.log("start switch ");
          return sw.start(function(result) {
            util.log("start switch result " + JSON.stringify(result));
            return callback();
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            util.log("error occured " + err);
            return cb(false);
          } else {
            util.log("startswitches all are processed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.createNodes = function(cb) {
      return async.each(this.nodeobj, (function(_this) {
        return function(n, callback) {
          util.log("createing a node ");
          return n.create(function(result) {
            var create;
            util.log("create node result " + result);
            create = false;
            return async.until(function() {
              return create;
            }, function(repeat) {
              return n.getstatus((function(_this) {
                return function(result) {
                  util.log(("node creation " + n.uuid + " status ") + result.data.status);
                  if (result.data.status !== "creation-in-progress") {
                    create = true;
                    n.start(function(result) {
                      util.log(("node start " + n.uuid + " result ") + result);
                    });
                  }
                  return setTimeout(repeat, 30000);
                };
              })(this));
            }, function(err) {
              util.log("createNodes completed execution");
              return callback(err);
            });
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            util.log("createNodes error occured " + err);
            return cb(false);
          } else {
            util.log("createNodes all are processed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.provisionNodes = function(cb) {
      return async.each(this.nodeobj, (function(_this) {
        return function(n, callback) {
          util.log("provisioning a node " + n.uuid);
          return n.provision(function(result) {
            util.log(("provision node " + n.uuid + " result  ") + result);
            return callback();
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            util.log("ProvisionNodes error occured " + err);
            return cb(false);
          } else {
            util.log("provisionNodes all are processed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.destroyNodes = function() {
      util.log("destroying the Nodes");
      return async.each(this.nodeobj, (function(_this) {
        return function(n, callback) {
          util.log("delete node " + n.uuid);
          return n.del(function(result) {
            return callback();
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            util.log("destroy nodes error occured " + err);
            return false;
          } else {
            util.log("destroyNodes all are processed " + _this.tmparray);
            return true;
          }
        };
      })(this));
    };

    Topology.prototype.destroySwitches = function() {
      util.log("destroying the Switches");
      return async.each(this.switchobj, (function(_this) {
        return function(n, callback) {
          util.log("delete switch " + n.uuid);
          return n.del(function(result) {
            return callback();
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            util.log("Destroy switches error occured " + err);
            return false;
          } else {
            util.log("Destroy Switches all are processed " + _this.tmparray);
            return true;
          }
        };
      })(this));
    };

    Topology.prototype.createLinks = function(cb) {
      return async.each(this.nodeobj, (function(_this) {
        return function(n, callback) {
          var ifmap, obj, _i, _len, _ref;
          util.log("create a Link");
          _ref = n.config.ifmap;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            ifmap = _ref[_i];
            if (ifmap.veth != null) {
              obj = _this.getSwitchObjbyName(ifmap.brname);
              if (obj != null) {
                obj.connect(ifmap.veth, function(res) {
                  return util.log("Link connect result" + res);
                });
              }
            }
          }
          return callback();
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            util.log("createLinks error occured " + err);
            return cb(false);
          } else {
            util.log("createLinks  all are processed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.create = function(_at_tdata, _at_projectdata) {
      var ipmgr, mgmtip, n, obj, sindex, startaddress, sw, swname, temp, val, x, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4;
      this.tdata = _at_tdata;
      this.projectdata = _at_projectdata;
      util.log("Topology create - topodata: " + JSON.stringify(this.tdata));
      util.log("Topology create - projectdata: " + JSON.stringify(this.projectdata));
      this.config = extend({}, tdata);
      this.config = extend(this.config, this.projectdata);
      this.uuid = this.tdata.id;
      util.log("topology config data " + JSON.stringify(this.config));
      util.log("vnetbuilderip  config " + this.config.vnetbuilderip);
      util.log("vnetprovisoiner ip  config " + this.config.vnetprovisionerip);
      ipmgr = new IPManager(this.config.wansubnet, this.config.lansubnet, this.config.mgmtsubnet);
      if (this.tdata.data.switches != null) {
        _ref = this.tdata.data.switches;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          sw = _ref[_i];
          obj = new switches(sw, this.config.vnetbuilderip, this.config.vnetprovisionerip);
          this.switchobj.push(obj);
        }
      }
      _ref1 = this.tdata.data.nodes;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        val = _ref1[_j];
        obj = new node(this.tdata.data.projectid, val, this.config.vnetbuilderip, this.config.vnetprovisionerip);
        mgmtip = ipmgr.getFreeMgmtIP();
        obj.addMgmtInterface(mgmtip, '255.255.255.0');
        this.nodeobj.push(obj);
      }
      sindex = 1;
      _ref2 = this.tdata.data.links;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        val = _ref2[_k];
        x = 0;
        if (val.type === "lan") {
          temp = ipmgr.getFreeLanSubnet();
          _ref3 = val.connected_nodes;
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            n = _ref3[_l];
            obj = this.getNodeObjbyName(n.name);
            if (obj != null) {
              startaddress = temp.iparray[x++];
              if (obj.config.type === "router") {
                obj.addLanInterface(val["switch"], startaddress, temp.subnetMask, null, val.config);
              }
              if (obj.config.type === "host") {
                obj.addLanInterface(val["switch"], startaddress, temp.subnetMask, temp.iparray[0], val.config);
              }
            }
          }
        }
        if (val.type === "wan") {
          temp = ipmgr.getFreeWanSubnet();
          swname = val.type + "_sw" + sindex;
          sindex++;
          util.log("  wan swname is " + swname);
          obj = new switches({
            name: swname,
            ports: 2,
            type: val.type,
            make: val.make
          }, this.config.vnetbuilderip, this.config.vnetprovisionerip);
          this.switchobj.push(obj);
          _ref4 = val.connected_nodes;
          for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
            n = _ref4[_m];
            obj = this.getNodeObjbyName(n.name);
            if (obj != null) {
              startaddress = temp.iparray[x++];
              obj.addWanInterface(swname, startaddress, temp.subnetMask, null, val.config);
            }
          }
        }
      }
      this.createSwitches((function(_this) {
        return function(res) {
          return util.log("createswitches result" + res);
        };
      })(this));
      return this.createNodes((function(_this) {
        return function(res) {
          util.log("topologycreation status" + res);
          return _this.createLinks(function(res) {
            util.log("create links result " + res);
            return _this.startSwitches(function(res) {
              util.log("start switches result " + res);
              util.log("Ready for provision");
              return _this.provisionNodes(function(res) {
                return util.log("provision" + res);
              });
            });
          });
        };
      })(this));
    };

    Topology.prototype.del = function() {
      var res, res1;
      res = this.destroyNodes();
      res1 = this.destroySwitches();
      return {
        "id": this.uuid,
        "status": "deleted"
      };
    };

    Topology.prototype.get = function() {
      var n, nodestatus, switchstatus, _i, _j, _len, _len1, _ref, _ref1;
      nodestatus = [];
      switchstatus = [];
      _ref = this.nodeobj;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        nodestatus.push(n.get());
      }
      _ref1 = this.switchobj;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        n = _ref1[_j];
        switchstatus.push(n.get());
      }
      return {
        "nodes": nodestatus,
        "switches": switchstatus
      };
    };

    return Topology;

  })();

  TopologyMaster = (function() {
    function TopologyMaster(filename) {
      this.registry = new TopologyRegistry(filename);
      this.topologyObj = {};
    }

    TopologyMaster.prototype.authenticate = function(data, callback) {
      var client;
      util.log("authenticate  input data is " + JSON.stringify(data));
      client = request.newClient("http://localhost:2222");
      return client.get("/project/" + data.projectid + "/passcode/" + data.passcode, (function(_this) {
        return function(err, res, body) {
          var _ref;
          if (err != null) {
            util.log("err" + JSON.stringify(err));
          }
          util.log("result body " + JSON.stringify(body));
          if ((res != null ? res.statusCode : void 0) != null) {
            util.log(" result " + res.statusCode);
          }
          if (res.statusCode === 200) {
            if ((body != null ? (_ref = body.data) != null ? _ref.projectid : void 0 : void 0) == null) {
              return callback(false, null);
            }
            if (body.data.projectid === data.projectid) {
              return callback(true, body.data);
            }
          }
          return callback(false, null);
        };
      })(this));
    };

    TopologyMaster.prototype.list = function(callback) {
      return callback(this.registry.list());
    };

    TopologyMaster.prototype.create = function(data, callback) {
      var err, topodata;
      try {
        return topodata = new TopologyData(null, data);
      } catch (_error) {
        err = _error;
        util.log("invalid schema" + err);
        return callback(new Error("Invalid Input "));
      } finally {
        util.log(JSON.stringify(topodata));
        this.authenticate(topodata.data, (function(_this) {
          return function(result, projectdata) {
            var i, li, obj, _i, _len;
            if (result === false) {
              return callback(new Error("Auth Failed"));
            }
            li = _this.registry.list();
            util.log("li  " + JSON.stringify(li));
            for (_i = 0, _len = li.length; _i < _len; _i++) {
              i = li[_i];
              util.log("iterating  i " + JSON.stringify(i));
              if (i.data.projectid === topodata.data.projectid) {
                util.log("Topology exists for the projectid " + topodata.data.projectid);
                util.log("Existing Topology details " + i.data);
                return callback(new Error("Topology already exists"));
              }
            }
            util.log("in topology creation");
            obj = new Topology;
            obj.create(topodata, projectdata);
            _this.topologyObj[obj.uuid] = obj;
            return callback(_this.registry.add(topodata));
          };
        })(this));
      }
    };

    TopologyMaster.prototype.del = function(id, callback) {
      var obj, result;
      obj = this.topologyObj[id];
      if (obj != null) {
        this.registry.remove(obj.uuid);
        delete this.topologyObj[id];
        result = obj.del();
        return callback(result);
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.get = function(id, callback) {
      var obj;
      obj = this.topologyObj[id];
      if (obj != null) {
        return callback(obj.get());
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.getproject = function(id, callback) {
      var i, result, tmp, _i, _len;
      tmp = [];
      result = [];
      tmp = this.registry.list();
      for (_i = 0, _len = tmp.length; _i < _len; _i++) {
        i = tmp[_i];
        if (i.data.projectid === id) {
          result.push(i);
        }
      }
      return callback(result);
    };

    TopologyMaster.prototype.deviceStats = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.stats((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceGet = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.getstatus((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceStatus = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.getrunningstatus((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceStart = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.start((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceStop = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.stop((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceTrace = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.trace((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceDelete = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.del((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    return TopologyMaster;

  })();

  module.exports = new TopologyMaster('/tmp/topology.db');

}).call(this);
