// Generated by CoffeeScript 1.7.1
(function() {
  var IPManager, StormData, StormRegistry, Topology, TopologyData, TopologyMaster, TopologyRegistry, async, extend, instance, ip, node, request, switches, util, vnetbuilderurl, vnetprovisionerurl,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  StormRegistry = require('stormregistry');

  StormData = require('stormdata');

  util = require('util');

  request = require('request-json');

  extend = require('util')._extend;

  ip = require('ip');

  async = require('async');

  vnetbuilderurl = 'http://localhost:5680/';

  vnetprovisionerurl = 'http://localhost:5681/';

  IPManager = require('./IPManager');

  node = require('./Node');

  switches = require('./Switches');

  TopologyRegistry = (function(_super) {
    __extends(TopologyRegistry, _super);

    function TopologyRegistry(filename) {
      this.on('load', function(key, val) {
        var entry;
        console.log("restoring " + key + " with:", val);
        entry = new TopologyData(key, val);
        if (entry != null) {
          entry.saved = true;
          return this.add(entry);
        }
      });
      this.on('removed', function(entry) {
        if (entry.destructor != null) {
          return entry.destructor();
        }
      });
      TopologyRegistry.__super__.constructor.call(this, filename);
    }

    TopologyRegistry.prototype.add = function(data) {
      var entry;
      if (!(data instanceof TopologyData)) {
        return;
      }
      return entry = TopologyRegistry.__super__.add.call(this, data.id, data);
    };

    TopologyRegistry.prototype.update = function(data) {
      return TopologyRegistry.__super__.update.call(this, data.id, data);
    };

    TopologyRegistry.prototype.get = function(key) {
      var entry;
      entry = TopologyRegistry.__super__.get.call(this, key);
      if (entry == null) {
        return;
      }
      if ((entry.data != null) && entry.data instanceof TopologyData) {
        entry.data.id = entry.id;
        return entry.data;
      } else {
        return entry;
      }
    };

    return TopologyRegistry;

  })(StormRegistry);

  TopologyData = (function(_super) {
    var TopologySchema;

    __extends(TopologyData, _super);

    TopologySchema = {
      name: "Topology",
      type: "object",
      additionalProperties: true,
      properties: {
        name: {
          type: "string",
          required: true
        },
        switches: {
          type: "array",
          items: {
            name: "switch",
            type: "object",
            required: false,
            additionalProperties: true,
            properties: {
              name: {
                type: "string",
                required: false
              },
              type: {
                type: "string",
                required: false
              },
              ports: {
                type: "integer",
                required: false
              }
            }
          }
        },
        nodes: {
          type: "array",
          items: {
            name: "node",
            type: "object",
            required: true,
            additionalProperties: true,
            properties: {
              name: {
                type: "string",
                required: true
              },
              type: {
                type: "string",
                required: false
              },
              Services: {
                type: "array",
                required: true,
                additionalProperties: true,
                items: {
                  type: "object",
                  required: true,
                  properties: {
                    name: {
                      "type": "string",
                      "required": false
                    },
                    enabled: {
                      "type": "boolean",
                      "required": false
                    }
                  }
                }
              }
            }
          }
        },
        links: {
          type: "array",
          items: {
            name: "node",
            type: "object",
            required: true,
            additionalProperties: true,
            properties: {
              type: {
                type: "string",
                required: true
              },
              "switch": {
                type: "string",
                required: false
              },
              connected_nodes: {
                type: "array",
                required: true,
                additionalProperties: true,
                items: {
                  type: "object",
                  required: true,
                  properties: {
                    name: {
                      "type": "string",
                      "required": true
                    }
                  }
                }
              }
            }
          }
        }
      }
    };

    function TopologyData(id, data) {
      TopologyData.__super__.constructor.call(this, id, data, TopologySchema);
    }

    return TopologyData;

  })(StormData);

  Topology = (function() {
    function Topology() {
      this.config = {};
      this.status = {};
      this.statistics = {};
      this.switchobj = [];
      this.nodeobj = [];
      this.linksobj = [];
      this.ipmgr = new IPManager("172.16.1.0", "10.10.10.0", "10.0.3.0");
    }

    Topology.prototype.getNodeObjbyName = function(name) {
      var obj, _i, _len, _ref;
      _ref = this.nodeobj;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        util.log("getNodeObjbyName" + obj.config.name);
        if (obj.config.name === name) {
          util.log("getNodeObjbyName found " + obj.config.name);
          return obj;
        }
      }
      return null;
    };

    Topology.prototype.getNodeObjbyUUID = function(uuid) {
      var obj, _i, _len, _ref;
      _ref = this.nodeobj;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        util.log("getNodeObjbyUUID" + obj.uuid);
        if (obj.uuid === uuid) {
          util.log("getNodeObjbyUUID found " + obj.config.uuid);
          return obj;
        }
      }
      return null;
    };

    Topology.prototype.createSwitches = function(cb) {
      var sw, _i, _len, _ref;
      _ref = this.switchobj;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sw = _ref[_i];
        sw.create();
      }
      return async.each(this.switchobj, (function(_this) {
        return function(sw, callback) {
          util.log("create switch ");
          return sw.create(function(result) {
            util.log("create switch result " + JSON.stringify(result));
            return callback();
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            console.log("error occured " + err);
            return cb(false);
          } else {
            console.log("createswitches all are processed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.createNodes = function(cb) {
      return async.each(this.nodeobj, (function(_this) {
        return function(n, callback) {
          util.log("create node ");
          return n.create(function(result) {
            var create;
            util.log("create node result " + result);
            create = false;
            return async.until(function() {
              return create;
            }, function(repeat) {
              return n.getstatus((function(_this) {
                return function(result) {
                  console.log("node creation status " + result.data.status);
                  if (result.data.status !== "creation-in-progress") {
                    create = true;
                    n.start(function(result) {
                      util.log("start node result" + result);
                    });
                  }
                  return setTimeout(repeat, 30000);
                };
              })(this));
            }, function(err) {
              console.log("completed execution");
              return callback(err);
            });
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            console.log("error occured " + err);
            return cb(false);
          } else {
            console.log("createNodes all are processed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.provisionNodes = function(cb) {
      return async.each(this.nodeobj, (function(_this) {
        return function(n, callback) {
          util.log("provision node ");
          return n.provision(function(result) {
            util.log("provision node result " + result);
            return callback();
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            console.log("error occured " + err);
            return cb(false);
          } else {
            console.log("provisionNodes all are processed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.destroyNodes = function() {
      this.tmparray = [];
      util.log("destroying the Nodes");
      return async.each(this.nodeobj, (function(_this) {
        return function(n, callback) {
          util.log("delete node " + n.uuid);
          return n.del(function(result) {
            _this.tmparray.push(result);
            return callback();
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            console.localhostg("error occured " + err);
            return false;
          } else {
            console.log("all are processed " + _this.tmparray);
            return true;
          }
        };
      })(this));
    };

    Topology.prototype.destroySwitches = function() {
      this.tmparray = [];
      util.log("destroying the Switches");
      return async.each(this.switchobj, (function(_this) {
        return function(n, callback) {
          util.log("delete switch " + n.uuid);
          return n.del(function(result) {
            _this.tmparray.push(result);
            return callback();
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            console.log("error occured " + err);
            return false;
          } else {
            console.log("all are processed " + _this.tmparray);
            return true;
          }
        };
      })(this));
    };

    Topology.prototype.create = function(tdata) {
      var mgmtip, n, obj, startaddress, sw, swname, temp, val, x, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4;
      this.tdata = tdata;
      util.log("Topology create: " + JSON.stringify(this.tdata));
      this.config = extend({}, tdata);
      this.uuid = this.tdata.id;
      _ref = this.tdata.data.switches;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sw = _ref[_i];
        obj = new switches(sw);
        this.switchobj.push(obj);
      }
      _ref1 = this.tdata.data.nodes;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        val = _ref1[_j];
        obj = new node(this.tdata.data.projectid, val);
        mgmtip = this.ipmgr.getFreeMgmtIP();
        obj.addMgmtInterface(mgmtip, '255.255.255.0');
        this.nodeobj.push(obj);
      }
      _ref2 = this.tdata.data.links;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        val = _ref2[_k];
        x = 0;
        if (val.type === "lan") {
          temp = this.ipmgr.getFreeLanSubnet();
          _ref3 = val.connected_nodes;
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            n = _ref3[_l];
            obj = this.getNodeObjbyName(n.name);
            if (obj != null) {
              startaddress = temp.iparray[x++];
              obj.addLanInterface(val["switch"], startaddress, temp.subnetMask);
            }
          }
        }
        if (val.type === "wan") {
          temp = this.ipmgr.getFreeWanSubnet();
          swname = "" + val.type + "_" + val.connected_nodes[0].name + "_" + val.connected_nodes[1].name;
          util.log("  wan swname is " + swname);
          obj = new switches({
            name: swname,
            ports: 2,
            type: "bridge"
          });
          this.switchobj.push(obj);
          _ref4 = val.connected_nodes;
          for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
            n = _ref4[_m];
            obj = this.getNodeObjbyName(n.name);
            if (obj != null) {
              startaddress = temp.iparray[x++];
              obj.addWanInterface(swname, startaddress, temp.subnetMask);
            }
          }
        }
      }
      this.createSwitches((function(_this) {
        return function(res) {
          return util.log("createswitches result" + res);
        };
      })(this));
      return this.createNodes((function(_this) {
        return function(res) {
          util.log("topologycreation status" + res);
          util.log("readu for provision");
          return _this.provisionNodes(function(res) {
            return util.log("provision" + res);
          });
        };
      })(this));
    };

    Topology.prototype.del = function() {
      var res, res1;
      res = this.destroyNodes();
      res1 = this.destroySwitches();
      return true;
    };

    Topology.prototype.get = function() {
      var n, nodestatus, switchstatus, _i, _j, _len, _len1, _ref, _ref1;
      nodestatus = [];
      switchstatus = [];
      _ref = this.nodeobj;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        nodestatus.push(n.get());
      }
      _ref1 = this.switchobj;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        n = _ref1[_j];
        switchstatus.push(n.get());
      }
      return {
        "nodes": nodestatus,
        "switches": switchstatus
      };
    };

    Topology.prototype.vmstatus = function(callback) {
      var arr, n, _i, _len, _ref, _results;
      arr = [];
      util.log("inside topoloy status function");
      _ref = this.nodeobj;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        _results.push(n.nodestatus((function(_this) {
          return function(val) {
            arr.push(val);
            return callback(arr);
          };
        })(this)));
      }
      return _results;
    };

    return Topology;

  })();

  TopologyMaster = (function() {
    function TopologyMaster(filename) {
      this.registry = new TopologyRegistry(filename);
      this.topologyobj = [];
    }

    TopologyMaster.prototype.getTopologyObj = function(data) {
      var obj, _i, _len, _ref;
      _ref = this.topologyobj;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        util.log("topologyobj" + obj.uuid);
        if (obj.uuid === data) {
          util.log("getTopologyObj found " + obj.uuid);
          return obj;
        }
      }
      return null;
    };

    TopologyMaster.prototype.list = function(callback) {
      return callback(this.registry.list());
    };

    TopologyMaster.prototype.create = function(data, callback) {
      var err, topodata;
      try {
        return topodata = new TopologyData(null, data);
      } catch (_error) {
        err = _error;
        util.log("invalid schema" + err);
        return callback(new Error("Invalid Input "));
      } finally {
        util.log(JSON.stringify(topodata));
        callback(this.registry.add(topodata));
        this.obj = new Topology;
        this.obj.create(topodata);
        this.topologyobj.push(this.obj);
      }
    };

    TopologyMaster.prototype.del = function(data, callback) {
      var obj;
      obj = this.getTopologyObj(data);
      if (obj != null) {
        this.registry.remove(obj.uuid);
        return callback(obj.del());
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.get = function(data, callback) {
      var obj;
      obj = this.getTopologyObj(data);
      if (obj != null) {
        return callback(obj.get());
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceStats = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.getTopologyObj(topolid);
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.stats((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceStatus = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.getTopologyObj(topolid);
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj !== null) {
          return callback(deviceobj.get());
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceStart = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.getTopologyObj(topolid);
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj !== null) {
          return callback(deviceobj.start());
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceStop = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.getTopologyObj(topolid);
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj !== null) {
          return callback(deviceobj.stop());
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    return TopologyMaster;

  })();

  ({
    deviceDelete: function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.getTopologyObj(topolid);
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj !== null) {
          return callback(deviceobj.del());
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    },
    status: function(data, callback) {
      var obj;
      obj = this.getTopologyObj(data);
      if (obj != null) {
        return callback(obj.vmstatus());
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    }
  });

  instance = new TopologyMaster('/tmp/topology.db');

  module.exports = instance;

}).call(this);
